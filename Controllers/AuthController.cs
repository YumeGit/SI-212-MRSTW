using MRSTW.Database;
using MRSTW.Models.View;
using System.Linq;
using System.Web.Mvc;

namespace MRSTW.Controllers
{
	public class AuthController : Controller
	{
		// GET: /Auth/Login
		public ActionResult Login()
		{
			return View();
		}

		// POST: /Auth/Login
		// Этот аттрибут определяет этот метод как экшн для ПОСТ запросов на адрес. 
		// ПОСТ запросы нужны для отправки данных на сервер с форм. 
		[HttpPost]
		// Этот аттрибут добавляет проверку от фабрикации запроса. Он удостоверяет, что запрос
		// был произведен именно с формы на нашем сайте. Если ты добавляешь этот аттрибут, шаблон формы
		// должен иметь @Html.AntiForgeryToken() внутри себя.
		[ValidateAntiForgeryToken]
		public ActionResult Login(LoginForm form)
		{
			// Проверяем, что все параметры что были нам отправлены вместе с POST запросом, 
			// подходят по нашим условиям: нет строковых значений для числовых переменных, 
			// все необъодимые паарметры были предоставлены + дополнительные проверки, что 
			// мы указали в определении LoginForm (через аттрибуты над свойствами)
			if(ModelState.IsValid)
			{
				// Создаем объект базы данных. using нужен для того чтобы, после
				// того как мы завершили выполнение всех операций в этом блоке,
				// база данных была автоматически отключена. Грубо говоря, аналог этой
				// штуки в C++ это сделать new ScheduleDbContext() до выполнения блока
				// и delete после выполнения.
				using (var db = new ScheduleDbContext())
				{
					// Из коллекции пользователей в нашей базе данных
					var user = db.Users
						// Мы берем тех пользователей, имейл и пароль которых совпадает с 
						// тем, что клиент отправил через форму. По определению этот метод
						// вернет множество элементов, но в нашем случае оно будет состоять 
						// только из одного элемента, ибо может существовать только один
						// пользователь с уникальной связкой адреса и пароля.
						.Where(u => u.Email == form.Email && u.Password == form.Password)
						// Возвращаем этот самый первый элемент во множестве пользователей.
						// Часть "OrDefault" означает, что если множество пустое, то он будет
						// возврашать дефолтное "пустое" значение вместо него. Для классов это 
						// будет NULL, для структур это сама структура, но со стандартными
						// значениями. (Заметка: в C# нет понятия "неопределенная переменная" и
						// "обнулять" переменную как в C++ не надо. Т.е. "int var" будет иметь
						// значение 0 по уполчанию.)
						.FirstOrDefault();

					// Если мы нашли пользователя, то значит авторизация прошла успешно,
					// перенаправляем клиента на главную страницу. И сохраняем его ID в сессии.
					if(user != null)
					{

						return Redirect("/");
					}

					// Если проверка выше не прошла, то это значит, что форма была заполена правильно,
					// но мы не смогли найти пользователя с такой парой ключей. В этом случае добавим 
					// сообщение на форму, что авторизация прошла безуспешно. Она будет отображаться рядом с
					// полем для ввода пароля.
					ModelState.AddModelError("Password", "Invalid login or password.");
				}
			}

			return View(form);
		}

		public ActionResult Register()
		{
			return View();
		}

		[HttpPost]
		[ValidateAntiForgeryToken]
		public ActionResult Register(RegisterForm vm)
		{
			return View();
		}
	}
}